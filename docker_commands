docker build -t front_image .
Tag for the image name
```
-t 
```
The directory where we are look for Dockerfile
```
.
``` 

docker run -d --name frontapp_container -p 8080:8080 frontapp_image

detached mode:
It runs the container in the background, so it doesnâ€™t block your terminal.
```
-d
```
Ports between the host and the container.
8080:8080 
host machine:port inside the container
```
-p
```
If Dockerfile has
```
EXPOSE 8080
```
You can use "-P"
So container listens on port 8080 at runtime.






docker-compose up -d


#############################################
. --file Dockerfile

-- file Dockerfile
but the the default we dont need to give this parameter
#############################################
dir frontapp && backapp
./mvnw clean verify

# Build frontapp image
docker build -t frontapp_image --build-arg JAR_FILE=frontapp/target/*.jar .
# Zsh shell globbing issue:
docker build -t frontapp_image --build-arg JAR_FILE="frontapp/target/*.jar" .

# Print out Labels of the container image
docker inspect --type image backapp_image | sed -n '/"Labels": {/,/}/p' | sed 's/[{}]//g' | awk NF
docker inspect --type image frontapp_image | sed -n '/"Labels": {/,/}/p' | sed 's/[{}]//g' | awk NF

# docker inspect --type image backapp_image: Retrieves the inspection data.
# sed -n '/"Labels": {/,/}/p': Extracts lines from the JSON starting from "Labels": { to }.
# sed 's/[{}]//g': Removes curly braces {}.
# awk NF: Prints only non-empty lines, making the output cleaner.


# Build backapp image
docker build -t backapp_image --build-arg JAR_FILE=backapp/target/*.jar .
# Zsh shell globbing issue:
docker build -t backapp_image --build-arg JAR_FILE="backapp/target/*.jar" .
